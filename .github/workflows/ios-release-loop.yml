name: iOS Release Loop

on:
  push:
    branches: [main]
    paths:
      - 'apps/ios/**'
      - '.github/workflows/ios-release-loop.yml'
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        type: choice
        options:
          - testflight
          - app_store
  workflow_call:

jobs:
  validate-release:
    name: Validate Release
    runs-on: macos-14
    timeout-minutes: 5
    outputs:
      version: ${{ steps.version.outputs.version }}
      build_number: ${{ steps.version.outputs.build_number }}
      
    steps:
    - uses: actions/checkout@v4
    
    - name: Validate preview checks
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "🔍 Validating that preview branch is green..."
        
        # Get latest preview branch status
        PREVIEW_STATUS=$(gh api repos/${{ github.repository }}/commits/preview/status --jq '.state')
        
        if [[ "$PREVIEW_STATUS" != "success" ]]; then
          echo "❌ Preview branch checks are not passing"
          echo "Status: $PREVIEW_STATUS"
          exit 1
        fi
        
        echo "✅ Preview branch is green"
    
    - name: Extract version info
      id: version
      run: |
        cd apps/ios
        
        # Get marketing version
        VERSION=$(/usr/libexec/PlistBuddy -c "Print CFBundleShortVersionString" LogYourBody/Info.plist)
        
        # Generate build number with timestamp
        BUILD_NUMBER=$(date -u +%Y%m%d%H%M%S)
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
        
        echo "📦 Version: $VERSION"
        echo "🔢 Build: $BUILD_NUMBER"

  # Reuse artifacts from preview if possible
  check-existing-build:
    name: Check Existing Build
    needs: validate-release
    runs-on: ubuntu-latest
    outputs:
      has_artifact: ${{ steps.check.outputs.exists }}
      artifact_url: ${{ steps.check.outputs.url }}
    
    steps:
    - name: Check for existing preview artifact
      id: check
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Look for recent successful preview builds
        echo "🔍 Checking for reusable preview build..."
        
        # This is a placeholder - in production, you'd check artifact storage
        echo "exists=false" >> $GITHUB_OUTPUT
        echo "ℹ️ No reusable build found, will build fresh"

  build-release:
    name: Build Release
    needs: [validate-release, check-existing-build]
    if: needs.check-existing-build.outputs.has_artifact != 'true'
    runs-on: macos-14
    timeout-minutes: 30
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: '16.1'
    
    - name: Install dependencies
      run: |
        cd apps/ios
        gem install bundler:2.4.10
        bundle config path vendor/bundle
        bundle install --jobs 4 --retry 3
    
    - name: Import Code Signing Certificates
      uses: apple-actions/import-codesign-certs@v5
      with:
        p12-file-base64: ${{ secrets.IOS_P12_BASE64 }}
        p12-password: ${{ secrets.IOS_P12_PASSWORD }}
        keychain-password: ${{ secrets.IOS_P12_PASSWORD }}
    
    - name: Download Provisioning Profile
      run: |
        mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
        # Use printf to handle multi-line base64 correctly
        printf '%s' "${{ secrets.IOS_PROVISIONING_PROFILE_BASE64 }}" | base64 --decode > provision.mobileprovision
        
        # Extract UUID and install with proper name
        uuid=$(/usr/libexec/PlistBuddy -c "Print :UUID" /dev/stdin <<< $(security cms -D -i provision.mobileprovision))
        cp provision.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/${uuid}.mobileprovision
        
        echo "Installed provisioning profile: ${uuid}.mobileprovision"
        echo "PROVISIONING_PROFILE_UUID=${uuid}" >> $GITHUB_ENV
        
        # Validate provisioning profile
        security cms -D -i provision.mobileprovision > profile_info.plist
        app_id=$(/usr/libexec/PlistBuddy -c "Print :Entitlements:application-identifier" profile_info.plist)
        team_id=$(/usr/libexec/PlistBuddy -c "Print :TeamIdentifier:0" profile_info.plist)
        
        echo "Provisioning Profile Info:"
        echo "  UUID: ${uuid}"
        echo "  App ID: ${app_id}"
        echo "  Team ID: ${team_id}"
        
        # Check for required capabilities
        echo "Checking required capabilities..."
        capabilities_ok=true
        
        # Check for HealthKit
        if ! /usr/libexec/PlistBuddy -c "Print :Entitlements:com.apple.developer.healthkit" profile_info.plist &>/dev/null; then
          echo "::warning::Missing HealthKit capability"
          capabilities_ok=false
        fi
        
        # Check for App Groups
        if ! /usr/libexec/PlistBuddy -c "Print :Entitlements:com.apple.security.application-groups:0" profile_info.plist &>/dev/null; then
          echo "::warning::Missing App Groups capability"
          capabilities_ok=false
        fi
        
        # Check for Associated Domains
        if ! /usr/libexec/PlistBuddy -c "Print :Entitlements:com.apple.developer.associated-domains" profile_info.plist &>/dev/null; then
          echo "::warning::Missing Associated Domains capability"
          capabilities_ok=false
        fi
        
        # Check for Sign in with Apple
        if ! /usr/libexec/PlistBuddy -c "Print :Entitlements:com.apple.developer.applesignin" profile_info.plist &>/dev/null; then
          echo "::warning::Missing Sign in with Apple capability"
          capabilities_ok=false
        fi
        
        # Verify it matches our expected values
        if [[ ! "$app_id" =~ "LogYourBody.LogYourBody" ]]; then
          echo "::error::Provisioning profile app ID mismatch. Expected LogYourBody.LogYourBody, got ${app_id}"
          exit 1
        fi
        
        if [[ "$capabilities_ok" == "false" ]]; then
          echo "::error::Provisioning profile is missing required capabilities. Please regenerate the profile with all required entitlements."
          exit 1
        fi
        
        rm -f profile_info.plist
    
    - name: Setup App Store Connect API Key
      run: |
        cd apps/ios
        # Use printf to avoid issues with special characters
        printf '%s' '${{ secrets.ASC_API_KEY_JSON }}' > app_store_connect_api_key.json
        echo "APP_STORE_CONNECT_API_KEY_PATH=$(pwd)/app_store_connect_api_key.json" >> $GITHUB_ENV
    
    - name: Create config files
      run: |
        cd apps/ios
        
        # Create Supabase config
        echo "// CI Placeholder" > Supabase.xcconfig
        echo "SUPABASE_URL = https://placeholder.supabase.co" >> Supabase.xcconfig
        echo "SUPABASE_ANON_KEY = placeholder-key" >> Supabase.xcconfig
        
        # Create LogYourBody config
        echo "// CI Placeholder" > LogYourBody/Config.xcconfig
        echo "CLERK_PUBLISHABLE_KEY = placeholder-clerk-key" >> LogYourBody/Config.xcconfig
    
    - name: Update version and build
      run: |
        cd apps/ios
        
        # Update build number
        /usr/libexec/PlistBuddy -c "Set :CFBundleVersion ${{ needs.validate-release.outputs.build_number }}" LogYourBody/Info.plist
        
        echo "📱 Building iOS app for release..."
    
    - name: Archive and export
      run: |
        cd apps/ios
        
        # Use Fastlane to build, capturing output for error detection
        bundle exec fastlane build_release 2>&1 | tee fastlane.log
        
        # Check for errors and surface them in the summary
        if grep -E "error:|duplicate|signing|Error:|ERROR:|Failed|FAILED" fastlane.log; then
          echo "::error::Build errors detected - see highlighted lines above"
          exit 1
        fi
      env:
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        IOS_PROVISIONING_PROFILE_NAME: ${{ secrets.IOS_PROVISIONING_PROFILE_NAME }}
    
    - name: Upload build artifact
      uses: actions/upload-artifact@v4
      with:
        name: ios-release-build
        path: apps/ios/build/*.ipa
        retention-days: 30
    
    - name: Cleanup
      if: always()
      run: |
        cd apps/ios
        rm -f app_store_connect_api_key.json

  deploy-testflight:
    name: Deploy to TestFlight
    needs: [validate-release, build-release]
    if: github.event.inputs.release_type != 'app_store'
    runs-on: macos-14
    timeout-minutes: 20
    environment:
      name: production-testflight
      url: https://testflight.apple.com
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Download build artifact
      uses: actions/download-artifact@v4
      with:
        name: ios-release-build
        path: apps/ios/build
    
    - name: Setup dependencies
      run: |
        cd apps/ios
        gem install bundler:2.4.10
        bundle config path vendor/bundle
        bundle install --jobs 4 --retry 3
    
    - name: Setup App Store Connect API Key
      run: |
        cd apps/ios
        # Use printf to avoid issues with special characters
        printf '%s' '${{ secrets.ASC_API_KEY_JSON }}' > app_store_connect_api_key.json
        echo "APP_STORE_CONNECT_API_KEY_PATH=$(pwd)/app_store_connect_api_key.json" >> $GITHUB_ENV
    
    - name: Run Fastlane Precheck
      run: |
        cd apps/ios
        bundle exec fastlane precheck 2>&1 | tee precheck.log
        
        # Check for errors and surface them in the summary
        if grep -E "error:|duplicate|signing|Error:|ERROR:|Failed|FAILED" precheck.log; then
          echo "::error::Precheck errors detected - see highlighted lines above"
          exit 1
        fi
      env:
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        APP_STORE_APP_ID: ${{ secrets.APP_STORE_APP_ID }}
    
    - name: Upload to TestFlight
      run: |
        cd apps/ios
        
        # Create release notes
        cat > release_notes.txt << EOF
        Version ${{ needs.validate-release.outputs.version }}
        Build ${{ needs.validate-release.outputs.build_number }}
        
        This is a production release candidate.
        
        Changes:
        - All features tested in preview environment
        - Ready for production release
        
        Please test thoroughly before App Store submission.
        EOF
        
        # Upload to TestFlight
        bundle exec fastlane upload_testflight \
          ipa_path:build/*.ipa \
          groups:"Production Testers,Beta Testers" \
          changelog_file:release_notes.txt 2>&1 | tee upload.log
        
        # Check for errors and surface them in the summary
        if grep -E "error:|duplicate|signing|Error:|ERROR:|Failed|FAILED" upload.log; then
          echo "::error::Upload errors detected - see highlighted lines above"
          exit 1
        fi
      env:
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        APP_STORE_APP_ID: ${{ secrets.APP_STORE_APP_ID }}
    
    - name: Cleanup
      if: always()
      run: |
        cd apps/ios
        rm -f app_store_connect_api_key.json
        rm -f release_notes.txt

  deploy-app-store:
    name: Deploy to App Store
    needs: [validate-release, build-release]
    if: github.event.inputs.release_type == 'app_store'
    runs-on: macos-14
    timeout-minutes: 30
    environment:
      name: production-app-store
      url: https://apps.apple.com/app/logyourbody
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Download build artifact
      uses: actions/download-artifact@v4
      with:
        name: ios-release-build
        path: apps/ios/build
    
    - name: Setup dependencies
      run: |
        cd apps/ios
        gem install bundler:2.4.10
        bundle config path vendor/bundle
        bundle install --jobs 4 --retry 3
    
    - name: Setup App Store Connect API Key
      run: |
        cd apps/ios
        # Use printf to avoid issues with special characters
        printf '%s' '${{ secrets.ASC_API_KEY_JSON }}' > app_store_connect_api_key.json
        echo "APP_STORE_CONNECT_API_KEY_PATH=$(pwd)/app_store_connect_api_key.json" >> $GITHUB_ENV
    
    - name: Run Fastlane Precheck
      run: |
        cd apps/ios
        bundle exec fastlane precheck 2>&1 | tee precheck.log
        
        # Check for errors and surface them in the summary
        if grep -E "error:|duplicate|signing|Error:|ERROR:|Failed|FAILED" precheck.log; then
          echo "::error::Precheck errors detected - see highlighted lines above"
          exit 1
        fi
      env:
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        APP_STORE_APP_ID: ${{ secrets.APP_STORE_APP_ID }}
    
    - name: Submit to App Store
      run: |
        cd apps/ios
        
        # Submit for review
        bundle exec fastlane submit_app_store \
          ipa_path:build/*.ipa \
          submit_for_review:false \
          automatic_release:false \
          phased_release:true 2>&1 | tee submit.log
        
        # Check for errors and surface them in the summary
        if grep -E "error:|duplicate|signing|Error:|ERROR:|Failed|FAILED" submit.log; then
          echo "::error::Submission errors detected - see highlighted lines above"
          exit 1
        fi
      env:
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        APP_STORE_APP_ID: ${{ secrets.APP_STORE_APP_ID }}
    
    - name: Cleanup
      if: always()
      run: |
        cd apps/ios
        rm -f app_store_connect_api_key.json

  create-release:
    name: Create Release
    needs: [validate-release, deploy-testflight, deploy-app-store]
    if: always() && (needs.deploy-testflight.result == 'success' || needs.deploy-app-store.result == 'success')
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Tag release
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        VERSION="ios-v${{ needs.validate-release.outputs.version }}"
        
        # Create git tag
        git config user.name "GitHub Actions"
        git config user.email "actions@github.com"
        git tag -a "$VERSION" -m "iOS Release $VERSION
        
        Build: ${{ needs.validate-release.outputs.build_number }}
        Deployment: ${{ github.event.inputs.release_type || 'testflight' }}"
        
        # Push tag
        git push origin "$VERSION"
        
        echo "✅ Tagged release: $VERSION"
    
    - name: Create GitHub release
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        VERSION="ios-v${{ needs.validate-release.outputs.version }}"
        DEPLOYMENT_TYPE="${{ github.event.inputs.release_type || 'TestFlight' }}"
        
        # Generate release notes
        gh release create "$VERSION" \
          --title "iOS Release $VERSION" \
          --notes "## 📱 iOS Release $VERSION
          
          **Build Number**: ${{ needs.validate-release.outputs.build_number }}
          **Deployment**: $DEPLOYMENT_TYPE
          
          ### Changes
          This release includes all changes that have been tested in the preview environment.
          
          ### Deployment Info
          - **Environment**: Production
          - **Commit**: ${{ github.sha }}
          - **Deployed by**: @${{ github.actor }}
          - **Workflow**: [View Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          
          ### Installation
          $(if [[ "$DEPLOYMENT_TYPE" == "app_store" ]]; then
            echo "- **App Store**: Pending review"
          else
            echo "- **TestFlight**: Available for all testers"
          fi)
          
          ---
          *Automated release via three-loop CI/CD system*"